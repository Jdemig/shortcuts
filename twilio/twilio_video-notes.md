# Twilio - Video Notes

"Everything you need to build with WebRTC." - Twilio

**Features**

* One-to-one or Multi-party
  + One-to-One
    - End-to-end encryption
    - Up to 10 Participants
  + Multi-party
    - Recording
    - Up to 50 Participants
* Recording
* REST orchestration
* Webhook notifications
* Room-based access control
* Management console
* Screen sharing
* Client-side UI control
* DataTrack
* Low latency media routing

See https://www.twilio.com/video and
https://www.twilio.com/docs/programmable-video for details.


## JavaScript Platform

See https://www.twilio.com/docs/api/video/javascript and
https://media.twiliocdn.com/sdk/js/video/v1/docs for details.

**Initial Onetime Setup**

* Install the SDK: `npm install --save twilio-video`
* Create an API Key: See https://www.twilio.com/console/video/runtime/api-keys

**General Steps**

The general steps to create a video/audio app is as follows:

1. Generate an Access Token
2. Connect to a room and start listening for room events
3. When new participants connect, start listening for participant events

**Generating an Access Token**

An access token is expected to be generated by one of your servers, not a Twilio
server.

See https://github.com/TwilioDevEd/video-access-token-server-node for a video
access token server for Node.js.  The basics are repeated below.

```js
// server.js
import dotenv from 'dotenv';
import express from 'express';
import Twilio from 'twilio';

// Load environment files for access to configuration Values.
dotenv.load();

const AccessToken = Twilio.jwt.AccessToken;
const VideoGrant = AccessToken.VideoGrant;

const app = express();

...

/**
 * Generate an Access Token for a chat application user - it generates a random
 * username for the client requesting a token, and takes a device ID as a query
 * parameter.
 */
app.get('/api/token', function (request, response) {
  const identity = request.query.identity || 'identity';
  const room = request.query.room;

  const opts = {
    ttl: 3600, // Seconds
    identity: identity,
    nbf: Date.now() - (60 * 1000),
  };
  let token = new AccessToken(
    process.env.TWILIO_ACCOUNT_SID,
    process.env.TWILIO_API_KEY,
    process.env.TWILIO_API_SECRET,
    opts
  );

  // Grant the access token Twilio Video capabilities.
  let grant = new VideoGrant({
    room: room,
  });
  token.addGrant(grant);

  // Add other grants depending on your application

  // Serialize the token to a JWT string and include it in a JSON response.
  let tokenJwt = token.toJwt();
  response.send(tokenJwt);
});
```

**Connecting to a Room**

Once you have an access token, you can connect to a room.

```js
import TwilioVideo from 'twilio-video';

getAccessToken()
  .then(({ token }) => {
    TwilioVideo.connect(token, {
      name: 'my-room',
      // Any other options
    })
      .then((room) => {
        let localParticipant = room.localParticipant;

        localParticipant.on('trackAdded', function (localTrack) {
          ...
        });
        localParticipant.on('trackDimensionsChanged', function (localVideoTrack) {
          ...
        });
        localParticipant.on('trackDisabled', function (localTrack) {
          ...
        });
        localParticipant.on('trackEnabled', function (localTrack) {
          ...
        });
        localParticipant.on('trackPublicationFailed', function (error, localTrack) {
          ...
        });
        localParticipant.on('trackPublished', function (localTrackPublication) {
          ...
        });
        localParticipant.on('trackRemoved', function (localTrack) {
          ...
        });
        localParticipant.on('trackStarted', function (localTrack) {
          ...
        });
        localParticipant.on('trackStopped', function (localTrack) {
          ...
        });
        localParticipant.once('disconnected', function (participant) {
          ...
        });

        room.on('participantConnected', function (remoteParticipant) {
          remoteParticipant.on('trackAdded', function (remoteTrack) {
            let kind = remoteTrack.kind;
            
            if (['data'].includes(kind)) {
              remoteTrack.on('message', (data, remoteDataTrack) => { ... });
            }
            if (['video'].includes(kind)) {
              remoteTrack.on('dimensionsChanged', (remoteVideoTrack) => {
                let { height, width } = remoteVideoTrack.dimensions;
                ...
              });
            }
            if (['audio', 'video'].includes(kind)) {
              remoteTrack.on('disabled', (remoteTrack) => { ... });
              remoteTrack.on('enabled', (remoteTrack) => { ... });
              remoteTrack.on('started', (remoteTrack) => { ... });
            }
            if (['audio', 'data', 'video'].includes(kind)) {
              remoteTrack.on('unsubscribed', (remoteTrack) => { ... });
            }
            if (['audio', 'video'].includes(kind)) {
              // One of the following:
              
              const mediaEl = remoteTrack.attach('<selector>');
              
              const mediaEl = remoteTrack.attach(myMediaEl);
            
              const mediaEl = remoteTrack.attach();
              // And attach to DOM
              $('.mediaElCt').append(mediaEl);
            }
          });
          remoteParticipant.on('trackDimensionsChanged', function (remoteVideoTrack) {
            ...
          });
          remoteParticipant.on('trackDisabled', function (remoteTrack) {
            ...
          });
          remoteParticipant.on('trackEnabled', function (remoteTrack) {
            ...
          });
          remoteParticipant.on('trackMessage', function (data, remoteDataTrack) {
            ...
          });
          remoteParticipant.on('trackRemoved', function (remoteTrack) {
            let kind = remoteTrack.kind;
            
            if (['audio', 'video'].includes(kind)) {
              const mediaEls = remoteTrack.detach();
              mediaEls.forEach(mediaEl => mediaEl.remove());
            }
          });
          remoteParticipant.on('trackStarted', function (remoteTrack) {
            ...
          });
          remoteParticipant.on('trackSubscribed', function (remoteTrack) {
            ...
          });
          remoteParticipant.on('trackSubscriptionFailed', function (error) {
            ...
          });
          remoteParticipant.on('trackUnsubscribed', function (remoteTrack) {
            ...
          });
          remoteParticipant.once('disconnected', function (participant) {
            ...
          });
        });
        room.on('participantDisconnected', function (remoteParticipant) {
          ...
        });
        room.on('recordingStarted', () => { ... });
        room.on('recordingStopped', () => { ... });
        room.on('trackAdded', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.on('trackDimensionsChanged', function (remoteVideoTrack, remoteParticipant) {
          ...
        });
        room.on('trackDisabled', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.on('trackEnabled', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.on('trackMessage', function (data, remoteDataTrack, remoteParticipant) {
          ...
        });
        room.on('trackRemoved', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.on('trackStarted', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.on('trackSubscribed', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.on('trackUnsubscribed', function (remoteTrack, remoteParticipant) {
          ...
        });
        room.once('disconnected', function(room, error) {
          if (error) {
            console.log('Unexpectedly disconnected:', error);
          }
          room.localParticipant.tracks.forEach(function (localTrack) {
            if (['audio', 'video'].includes(localTrack.kind)) {
              localTrack.stop();
              localTrack.detach();
            }
          });
        });
      });
  })
```
